# shell-emulator
Дорохова А.С. ИКБО-30-24. Вариант 5. 
Проект: эмулятор командной оболочки (как командная строка), который работает с виртуальной файловой системой. Выполнен в 5 этапов, каждый этап добавляет новую функциональность.

Этап 1 - Базовые команды
exit - выход из программы
ls - список файлов
cd - переход между папками

Этап 2 - Скрипты
Запуск программы со скриптами
Автоматическое выполнение команд из файла

Этап 3 - Виртуальная файловая система (VFS)
Работа с файлами из ZIP-архива
Команды `pwd` и `cat` для работы с файлами

Этап 4 - Новые команды
tac - показывает файл задом наперед
du - показывает размеры файлов и папок

Этап 5 - Права доступа
chown - меняет владельца файлов
ls -l - показывает подробную информацию о файлах

В каждой папке (кроме первой )есть:
emulator.py - основная программа
run_interactive.bat - для запуска в Windows
run_test.bat - для тестирования
test_script.txt - тестовые команды


Этап 1. REPL
Цель: создать минимальный прототип. Большинство функций в нем пока представляют собой заглушки, но диалог с пользователем уже поддерживается.
Требования:
1.Приложение должно быть реализовано в форме консольного интерфейса (CLI).
Код:
<img width="829" height="189" alt="image" src="https://github.com/user-attachments/assets/9ccbf15a-882a-46b2-a8c1-b7356ddcc46c" />
Вывод:

2.Приглашение к вводу должно формироваться на основе реальных данных ОС, в которой исполняется эмулятор. Пример: username@hostname:~$.
Код:
<img width="581" height="37" alt="image" src="https://github.com/user-attachments/assets/30d391f3-50dc-4312-bcce-83b2c60fd596" />
<img width="607" height="21" alt="image" src="https://github.com/user-attachments/assets/08c315a6-4011-4446-a5da-07dbfaf8a0c3" />

Вывод:

3.Реализовать простой парсер, который разделяет ввод на команду и аргументы по пробелам.
Код:
<img width="328" height="138" alt="image" src="https://github.com/user-attachments/assets/6ef765b6-bcab-46db-be6f-0689690a1d8b" />

Вывод:

4.Реализовать команды-заглушки, которые выводят свое имя и аргументы: ls, cd.
Код:
<img width="538" height="212" alt="image" src="https://github.com/user-attachments/assets/020ac1a9-c6f5-4779-ab4d-f996ae2cc500" />

Вывод:

5.Реализовать команду exit.
Код:
<img width="316" height="74" alt="image" src="https://github.com/user-attachments/assets/5b7b2e5c-9d21-4663-a636-3d44c1d5ae3c" />

Вывод:

6.Продемонстрировать работу прототипа в интерактивном режиме. Необходимо показать примеры работы всей реализованной функциональности, включая обработку ошибок.
Код:
<img width="512" height="148" alt="image" src="https://github.com/user-attachments/assets/0c069ac3-4bb8-4579-b848-291f877cbdd5" />

Вывод:




Этап 2. Конфигурация
Цель: сделать эмулятор настраиваемым, то есть поддержать ввод параметров пользователя в приложение. Организовать для этого этапа отладочный вывод всех заданных параметров при запуске эмулятора.
Требования:
1.Параметры командной строки:
–Путь к физическому расположению VFS.
–Путь к стартовому скрипту.
Код:
<img width="1166" height="106" alt="image" src="https://github.com/user-attachments/assets/581c33f1-8e58-4aab-b1ad-0ca069c2cb23" />
Вывод:



2.Стартовый скрипт для выполнения команд эмулятора: останавливается при первой ошибке. При выполнении скрипта на экране отображается как ввод, так и вывод, имитируя диалог с пользователем.
Код:


Вывод:

3.Сообщить об ошибке во время исполнения стартового скрипта.
Код:

Вывод:

4.Создать несколько скриптов реальной ОС, в которой выполняется эмулятор. Включить в каждый скрипт вызовы эмулятора для тестирования всех поддерживаемых параметров командной строки.
Код:

Вывод:



Этап 3. VFS
Цель: подключить виртуальную файловую систему (VFS).
Требования:
1.Все операции должны производиться в памяти. Запрещается распаковывать или иным образом модифицировать данные VFS, за исключением возможных служебных команд.
Код:

Вывод:

2.Источником VFS является ZIP-архив. Для двоичных данных используется base64 или аналогичный формат.
Код:

Вывод:

3.Создать несколько скриптов реальной ОС, в которой выполняется эмулятор. Включить в каждый скрипт вызовы эмулятора для тестирования работы c различными вариантами VFS (минимальный, несколько файлов, не менее 3 уровней файлов и папок).
Код:

Вывод:

4.Создать стартовый скрипт для тестирования всех реализованных на этом и прошлых этапах команд. Добавить туда примеры всех режимов команд, включая работу с VFS и обработку ошибок.
Код:

Вывод:


Этап 4. Основные команды
Цель: поддержать команды, имитирующие работу в UNIX-подобной командной строке.
Требования:
1.Необходимо реализовать логику для ls и cd.
Код:

Вывод:

2.Реализовать новые команды: tac, du.
Код:

Вывод:

3.Создать стартовый скрипт для тестирования всех реализованных на этом этапе команд. Добавить туда примеры всех режимов команд, включая работу с VFS и обработку ошибок.
Код:

Вывод:




Этап 5. Дополнительные команды
Цель: поддержать более сложные команды, изменяющие состояние VFS, при этом модификации должны осуществляться только в памяти.
Требования:
1.Реализовать команды: chown.
Код:
<img width="618" height="511" alt="image" src="https://github.com/user-attachments/assets/66417725-8ab0-4fb2-b1b0-642881c4bd8b" />

Вывод:

2.Создать стартовый скрипт для тестирования всех реализованных на этом этапе команд. Добавить туда примеры всех режимов команд, включая работу с VFS и обработку ошибок.
Код:

Вывод:


